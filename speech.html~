<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Leap-Demo</title>
     <!-- Bootstrap -->
     <link rel="stylesheet" href="https://
maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/
bootstrap.min.css">
     <!-- Optional theme -->
<link  href="https://maxcdn.bootstrapcdn.com/
bootstrap/3.3.5/css/bootstrap-theme.min.css"
Rel="stylesheet" id="bs-theme-stylesheet">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
</head>
  <body>

    <div class ="container">
       <h3> Leap Notebook </h3>
    </div>

    <div "padding-left: 50px;">
      <p id="Instructions"> The blue node is the node with focus, add nodes to the blue node by pressing 'n', use the arrow keys to traverse the tree. If you have a Leap Motion Controller you can add nodes by making and releasing a fist. To traverse the tree with a Leap Controller swipe up, down, left, or right.  <p>
    <div>
    
    <button onclick="speechRecognition()">Speak a note</button>

    <div>
      <p id="cout_0"> cout_0  <p>
    <div>
    <div>
      <p id="cout_1"> cout_1 <p>
    <div>

    <element onkeypress="check"><element>

    <script src="http://js.leapmotion.com/leap-0.6.3.min.js"></script>

    <style type="text/css">

      h3 {
        color: red;
      }

      #notebookCanvas{
        width: 300 ;
        height: 300; 
        border:2px solid #000000;
      }

      p {
        display: block;
        margin-top: 1em;
        margin-bottom: 1em;
        margin-left: 5em;
        margin-right: 0;
        padding-right: 50px;
      }
      
    </style>

    <script>

      var focus;
      // svg is the document element we will draw the nodes to. heigth and width of element defined globally
      var svg;
      var svgHeight = 400;
      var svgWidth = 1200;

      // root is a reference to the parent node, node with focus is current selected node
      var root;
      var nodeWithFocus;

      // variables for simple text output <p> and 
      var cout_0;
      var cout_1;
      var clicks = 0;

      //node object define width and height globbal these the the rx and ry of an ellipse
      var nodeWidth = 40;
      var nodeHeight = 20;

      var textAreaWidthPX = "120px";
      var textAreaHeightPX = "40px";

      // integer version of PX
      var textAreaWidth = 120;
      var textAreaHeight = 40;

      var spaceBetweenGenerations = 3*nodeHeight;
      var spaceBetweenNodes = 1.5*textAreaWidth;

      //takes a position and depth, also a reference to parent
      function node(x, y, depth, parent){
        this.x = x;
        this.y = y;
        this.depth = depth;
        this.parent = parent;
        this.children = [];
        //index of child to give focus on right/down tree
        this.favoredChild = 0;
        this.fill = 'green';
        this.textContent = "Hello I am a node, look at me!";
        this.opacity = 1; 

        //determines distance between generations
        this.addChildren = function(){
          var temp = new node(this.x + spaceBetweenNodes, this.y, this.depth + 1, this);
          temp.value = "child";
          this.children.push(temp);
          this.arrangeChildren();
        };

        //changes childrens y coord based on this.y;
        this.arrangeChildren = function(){
          var numberOfChildren = this.children.length;
          if(numberOfChildren == 0){
            return;
          }
          var verticalRange = 2*nodeHeight*numberOfChildren + spaceBetweenGenerations*(numberOfChildren - 1);
          var childYcoord = (this.y - verticalRange/2) + nodeHeight;

          var childIndex = 0;
          while(childIndex < numberOfChildren){
            this.children[childIndex].y = childYcoord;
            childYcoord += (2*nodeHeight) + spaceBetweenGenerations;  // adding is going down
            childIndex++;
          }
        };

        // hide child nodes when their parent loses focus
        this.changeChildrenVisibility = function() { 
          var numberOfChildren = this.children.length;
          var childIndex = 0; 
          while(childIndex < numberOfChildren) {
            var child = this.children[childIndex];
            child.opacity = 0; 
            console.log(child);
            childIndex++; 
          }
        }; 
      }// end node



      function drawNode(node, offsetX, offsetY){
        //drawing elipse

        var x = node.x + offsetX;
        var y = node.y + offsetY;



        var ellipse = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
        ellipse.setAttribute("cx",x);
        ellipse.setAttribute("cy",y);
        ellipse.setAttribute("rx",nodeWidth);
        ellipse.setAttribute("ry",nodeHeight);
        ellipse.setAttribute("fill", node.fill);
        svg1.appendChild(ellipse);

        // add fix so text does not draw if off svg1 screen
        if(x < -10 || y < -10 || svgWidth < x || svgHeight < y)
          return;

        //drawing text area
        var foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
        //foreignObject.setAttribute("id", "y");
        foreignObject.setAttribute("x", x - textAreaWidth/2);
        foreignObject.setAttribute("y", y + nodeHeight);
        var textArea = document.createElement("textArea");
        textArea.style.width = textAreaWidthPX;
        textArea.style.height = textAreaHeightPX;
        textArea.innerHTML = node.textContent;
        foreignObject.appendChild(textArea);
        svg1.appendChild(foreignObject);
      }

      // undraws all the nodes from the screen, does not delete them
      function clearTree(){
        while (svg1.firstChild) {
          svg1.removeChild(svg1.firstChild);
        }
      };

      //recursivly draws tree structure from node down
      function drawTree(node){
        var offsetX = svgWidth/2 - nodeWithFocus.x ;
        var offsetY = svgHeight/2 - nodeWithFocus.y;

        if(node == nodeWithFocus)
          node.fill = 'blue';
        else
          node.fill = 'green';
        node.arrangeChildren();
        drawNode(node,offsetX,offsetY);

        var childIndex = 0;
        while(childIndex < node.children.length){
          connectNodes(node, node.children[childIndex], offsetX, offsetY);
          drawTree(node.children[childIndex]);
          childIndex++;
        }
      };

      //assumes child is right of parent, accepts an offset;
      function connectNodes(parent, child, offsetX, offsetY){
        var x1 = parent.x + nodeWidth + offsetX;
        var y1 = parent.y + offsetY;
        var x2 = child.x - nodeWidth + offsetX;
        var y2 = child.y + offsetY;
        drawLine(x1, y1, x2, y2);
      }

      function drawLine(x1, y1, x2, y2){
        var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1",x1);
        line.setAttribute("y1",y1);
        line.setAttribute("x2",x2);
        line.setAttribute("y2",y2);
        line.setAttribute("stroke", 'black');
        line.setAttribute("stroke-width", 2);
        svg1.appendChild(line);
      }

      function redrawTree(){
        clearTree();
        drawTree(root);
      }

      //Function called by key press up event as well as swipe up.
      function upEvent(){
        cout_0.innerHTML = "up/traverse children up";
        if(nodeWithFocus.parent != "no parent" && (nodeWithFocus.parent.favoredChild - 1) >= 0){
          nodeWithFocus.parent.favoredChild--;
          nodeWithFocus = nodeWithFocus.parent.children[nodeWithFocus.parent.favoredChild];
          redrawTree();
        }
      }

      //Function called by key press down event as well as swipe down.
      function downEvent(){
        cout_0.innerHTML = "down/traverse children down";
        if(nodeWithFocus.parent != "no parent" && (nodeWithFocus.parent.favoredChild + 1) < nodeWithFocus.parent.children.length){
          nodeWithFocus.parent.favoredChild++;
          nodeWithFocus = nodeWithFocus.parent.children[nodeWithFocus.parent.favoredChild];
         redrawTree();
        }
      }

      //Function called by key press left event as well as swipe left.
      function leftEvent(){
        cout_0.innerHTML = "left/up tree";
        if(nodeWithFocus.parent != "no parent"){
          nodeWithFocus = nodeWithFocus.parent;
          redrawTree();
        }
      }

      //Function called by key press right event as well as swipe right.
      function rightEvent(){
        cout_0.innerHTML = "right/down tree";
        if(nodeWithFocus.children.length > 0){
          nodeWithFocus = nodeWithFocus.children[nodeWithFocus.favoredChild]; 
          redrawTree();
        }
      }

      //Function Called for new node even (key press n or grab release)
      function newNodeEvent(){
                    cout_0.innerHTML = "n/new node";
            nodeWithFocus.addChildren();
            redrawTree();
      }

      //Leap variables and code
      var GRAB_THRESHOLD = 0.8;
      var handPresent = false;
      var grabbing = false;
      var swiping = false;
      var controllerOptions = {enableGestures: true};
      Leap.loop(controllerOptions, function(frame) {
        if (frame.gestures.length > 0) {
          for (var i = 0; i < frame.gestures.length; ++i) {
            var gesture = frame.gestures[i];
            /*
            if (gesture.type === "circle") {
              cout_0.innerHTML = "n/new node";
              nodeWithFocus.addChildren();
              redrawTree();
            }
            */
            if (gesture.type === "swipe") {
              if (!swiping && gesture.state === "start") {
                swiping = true;
                var xDir = gesture.direction[0];
                var yDir = gesture.direction[1];
                var swipeState = gesture.state;
                console.log("swipe:", swipeState, xDir, yDir);
                if (Math.abs(yDir) >= Math.abs(xDir)) {
                  if (yDir >= 0) {
                    upEvent();
                  } else {
                    downEvent();
                  }
                } else {
                  if (xDir <= 0) {
                    leftEvent();
                  } else {
                    rightEvent();
                  }
                }
              } else if (swiping && gesture.type === "stop") {
                swiping = false;
                var xDir = gesture.direction[0];
                var yDir = gesture.direction[1];
                var swipeState = gesture.state;
                console.log("swipe:", swipeState, xDir, yDir);
              }
            }
          }
        } else if (swiping) {
          swiping = false;
          console.log("no gesture");
        }
        if (frame.hands.length == 1) {
          hand = frame.hands[0];
          if (!handPresent) {
            handPresent = true;
            if (hand.grabStrength >= GRAB_THRESHOLD) {
              grabbing = true;
            } else {
              grabbing = false;
            }
          } else {
            if (!grabbing && hand.grabStrength >= GRAB_THRESHOLD) {
              grabbing = true;
            } else if (grabbing && hand.grabStrength < GRAB_THRESHOLD) {
              grabbing = false;
              newNodeEvent();
            }
          }
        } else {
          handPresent = false;
        }
      });// Leap loop

      //initializes a listener that records focus. Must click on canvas to give it focus for keydown events to trigger
      //initializes 4 different listeners that are currently triggered by key press events
      window.onload = function(){

        cout_0 = document.getElementById("cout_0");
        cout_1 = document.getElementById("cout_1");
        cout_0.innerHTML = "onload";

        svg1 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg1.setAttribute("height",svgHeight);
        svg1.setAttribute("width",svgWidth);
        document.body.appendChild(svg1);

        //establishes root node
        root = new node(200,200,0, "no parent");
        nodeWithFocus = root;
        redrawTree();

        document.addEventListener('mousedown', function(event) {
          lastDownTarget = event.target;
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 38) {
            upEvent();
          }
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 40) {
            downEvent();
          }
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 37) {
            leftEvent();
          }
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 39) {
            rightEvent();
          }
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 78) {
           newNodeEvent();
          }
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 82) {
            cout_0.innerHTML = "r";
            var foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
            foreignObject.setAttribute("id", "y");
            foreignObject.setAttribute("x", "200");
            foreignObject.setAttribute("y", "200");
            foreignObject.setAttribute("width", "300");
            foreignObject.setAttribute("height", "100");
            var textArea = document.createElement("textArea");
            textArea.style.width = "200px";
            textArea.style.height = "200px";
            textArea.innerHTML = "hello world ajf;askdjf;klasjf;asjf;jaskfja;sjf;lkasjf;kasj;jfa;ldkfja;skljf;kasdjf;klasj";
            foreignObject.appendChild(textArea);
            svg1.appendChild(foreignObject);
            
            //document.body.appendChild(text);

            check();

          }
        });

      } //Onload

      // Just a function to call to track scope
      function check(){ 
        clicks++;
        cout_1.innerHTML = "fun" + clicks;
        
      }

      var speechRecognition = function () { 
        var recognition = new webkitSpeechRecognition();
        recognition.onresult = function(event) { 
          var topResult = event['results'][0][0]['transcript'];
          nodeWithFocus.textContent = topResult;
          redrawTree(); 
        }
        recognition.start();
      }


    </script>
  </body>
</html>