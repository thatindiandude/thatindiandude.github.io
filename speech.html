<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Leap-Demo</title>
     <!-- Bootstrap -->
     <link rel="stylesheet" href="https://
maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/
bootstrap.min.css">
     <!-- Optional theme -->
<link  href="https://maxcdn.bootstrapcdn.com/
bootstrap/3.3.5/css/bootstrap-theme.min.css"
Rel="stylesheet" id="bs-theme-stylesheet">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
</head>
  <body>

    <div class ="container">
	     <h3> Leap Notebook </h3>
    </div>

    <div "padding-left: 50px;">
      <p id="Instructions"> The blue node is the node with focus, add nodes to the blue node by pressing 'n', use the arrow keys to traverse the tree.  <p>
    <div>
    
    <button onclick="speechRecognition()">Speak a note</button>

    <div>
      <p id="cout_0"> cout_0  <p>
    <div>
    <div>
      <p id="cout_1"> cout_1 <p>
    <div>

    <element onkeypress="check"><element>

    <style type="text/css">

      h3 {
        color: red;
      }

      #notebookCanvas{
        width: 300 ;
        height: 300; 
        border:2px solid #000000;
      }

      p {
        display: block;
        margin-top: 1em;
        margin-bottom: 1em;
        margin-left: 5em;
        margin-right: 0;
        padding-right: 50px;
      }
      
    </style>

    <script>

      var focus;
      // svg is the document element we will draw the nodes to. heigth and width of element defined globally
      var svg;
      var svgHeight = 400;
      var svgWidth = 1200;

      // root is a reference to the parent node, node with focus is current selected node
      var root;
      var nodeWithFocus;

      // variables for simple text output <p> and 
      var cout_0;
      var cout_1;
      var clicks = 0;

      //node object define width and height globbal these the the rx and ry of an ellipse
      var nodeWidth = 40;
      var nodeHeight = 20;

      var textAreaWidthPX = "120px";
      var textAreaHeightPX = "40px";

      // integer version of PX
      var textAreaWidth = 120;
      var textAreaHeight = 40;

      var spaceBetweenGenerations = 3*nodeHeight;
      var spaceBetweenNodes = 1.5*textAreaWidth;

      //takes a position and depth, also a reference to parent
      function node(x, y, depth, parent){
        this.x = x;
        this.y = y;
        this.depth = depth;
        this.parent = parent;
        this.children = [];
        //index of child to give focus on right/down tree
        this.favoredChild = 0;
        this.fill = 'green';
        this.textContent = "Hello I am a node, look at me!";
        this.opacity = 1; 

        //determines distance between generations
        this.addChildren = function(){
          var temp = new node(this.x + spaceBetweenNodes, this.y, this.depth + 1, this);
          temp.value = "child";
          this.children.push(temp);
          this.arrangeChildren();
        };

        //changes childrens y coord based on this.y;
        this.arrangeChildren = function(){
          var numberOfChildren = this.children.length;
          if(numberOfChildren == 0){
            return;
          }
          var verticalRange = 2*nodeHeight*numberOfChildren + spaceBetweenGenerations*(numberOfChildren - 1);
          var childYcoord = (this.y - verticalRange/2) + nodeHeight;

          var childIndex = 0;
          while(childIndex < numberOfChildren){
            this.children[childIndex].y = childYcoord;
            childYcoord += (2*nodeHeight) + spaceBetweenGenerations;  // adding is going down
            childIndex++;
          }
        };

        // hide child nodes when their parent loses focus
        this.changeChildrenVisibility = function() { 
          var numberOfChildren = this.children.length;
          var childIndex = 0; 
          while(childIndex < numberOfChildren) {
            var child = this.children[childIndex];
            child.opacity = 0; 
            console.log(child);
            childIndex++; 
          }
        }; 
      }// end node



      function drawNode(node, offsetX, offsetY){
        //drawing elipse

        var x = node.x + offsetX;
        var y = node.y + offsetY;

        // add fix so nodes and text do not draw if off screen;

        var ellipse = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
        ellipse.setAttribute("cx",x);
        ellipse.setAttribute("cy",y);
        ellipse.setAttribute("rx",nodeWidth);
        ellipse.setAttribute("ry",nodeHeight);
        ellipse.setAttribute("fill", node.fill);
        svg1.appendChild(ellipse);

        //drawing text area
        var foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
        //foreignObject.setAttribute("id", "y");
        foreignObject.setAttribute("x", x - textAreaWidth/2);
        foreignObject.setAttribute("y", y + nodeHeight);
        var textArea = document.createElement("textArea");
        textArea.style.width = textAreaWidthPX;
        textArea.style.height = textAreaHeightPX;
        textArea.innerHTML = node.textContent;
        foreignObject.appendChild(textArea);
        svg1.appendChild(foreignObject);
      }

      // undraws all the nodes from the screen, does not delete them
      function clearTree(){
        while (svg1.firstChild) {
          svg1.removeChild(svg1.firstChild);
        }
      };

      //recursivly draws tree structure from node down
      function drawTree(node){
        var offsetX = svgWidth/2 - nodeWithFocus.x ;
        var offsetY = svgHeight/2 - nodeWithFocus.y;

        if(node == nodeWithFocus)
          node.fill = 'blue';
        else
          node.fill = 'green';
        node.arrangeChildren();
        drawNode(node,offsetX,offsetY);

        var childIndex = 0;
        while(childIndex < node.children.length){
          connectNodes(node, node.children[childIndex], offsetX, offsetY);
          drawTree(node.children[childIndex]);
          childIndex++;
        }
      };

      //assumes child is right of parent, accepts an offset;
      function connectNodes(parent, child, offsetX, offsetY){
        var x1 = parent.x + nodeWidth + offsetX;
        var y1 = parent.y + offsetY;
        var x2 = child.x - nodeWidth + offsetX;
        var y2 = child.y + offsetY;
        drawLine(x1, y1, x2, y2);
      }

      function drawLine(x1, y1, x2, y2){
        var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1",x1);
        line.setAttribute("y1",y1);
        line.setAttribute("x2",x2);
        line.setAttribute("y2",y2);
        line.setAttribute("stroke", 'black');
        line.setAttribute("stroke-width", 2);
        svg1.appendChild(line);
      }

      function redrawTree(){
        clearTree();
        drawTree(root);
      }

      //initializes a listener that records focus. Must click on canvas to give it focus for keydown events to trigger
      //initializes 4 different listeners that are currently triggered by key press events
      window.onload = function(){

        cout_0 = document.getElementById("cout_0");
        cout_1 = document.getElementById("cout_1");
        cout_0.innerHTML = "onload";

        svg1 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg1.setAttribute("height",svgHeight);
        svg1.setAttribute("width",svgWidth);
        document.body.appendChild(svg1);

        //establishes root node
        root = new node(200,200,0, "no parent");
        nodeWithFocus = root;
        redrawTree();

        document.addEventListener('mousedown', function(event) {
          lastDownTarget = event.target;
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 38) {
            cout_0.innerHTML = "up/traverse children up";
            if((nodeWithFocus.parent.favoredChild - 1) >= 0){
              nodeWithFocus.parent.favoredChild--;
              nodeWithFocus = nodeWithFocus.parent.children[nodeWithFocus.parent.favoredChild];
              redrawTree();
            }
          }
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 40) {
            cout_0.innerHTML = "down/traverse children down";
            if((nodeWithFocus.parent.favoredChild + 1) < nodeWithFocus.parent.children.length){
              nodeWithFocus.parent.favoredChild++;
              nodeWithFocus = nodeWithFocus.parent.children[nodeWithFocus.parent.favoredChild];
              redrawTree();
            }
          }
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 37) {
            cout_0.innerHTML = "left/up tree";
            if(nodeWithFocus.parent != "no parent")
              nodeWithFocus = nodeWithFocus.parent;
              nodeWithFocus.changeChildrenVisibility(); 
              // redrawTree();
          }
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 39) {
            cout_0.innerHTML = "right/down tree";
            if(nodeWithFocus.children.length > 0)
              nodeWithFocus = nodeWithFocus.children[nodeWithFocus.favoredChild]; 
              redrawTree();
          }
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 78) {
            cout_0.innerHTML = "n/new node";
            nodeWithFocus.addChildren();
            redrawTree();

          }
        });

        document.addEventListener('keydown', function(event) {
          if(event.keyCode == 82) {
            cout_0.innerHTML = "r";
            var foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
            foreignObject.setAttribute("id", "y");
            foreignObject.setAttribute("x", "200");
            foreignObject.setAttribute("y", "200");
            foreignObject.setAttribute("width", "300");
            foreignObject.setAttribute("height", "100");
            var textArea = document.createElement("textArea");
            textArea.style.width = "200px";
            textArea.style.height = "200px";
            textArea.innerHTML = "hello world ajf;askdjf;klasjf;asjf;jaskfja;sjf;lkasjf;kasj;jfa;ldkfja;skljf;kasdjf;klasj";
            foreignObject.appendChild(textArea);
            svg1.appendChild(foreignObject);
            
            //document.body.appendChild(text);

            check();

          }
        });

      }

      // Just a function to call to track scope
      function check(){ 
        clicks++;
        cout_1.innerHTML = "fun" + clicks;
        
      }

      var speechRecognition = function () { 
        var recognition = new webkitSpeechRecognition();
        recognition.onresult = function(event) { 
          console.log(event['results'][0][0]['transcript']);
        }
        recognition.start();
      }


    </script>
  </body>
</html>